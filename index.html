<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Host Compromise Investigation</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1a1a2e; /* Darker background */
            color: #e0e0e0;
            line-height: 1.6;
        }

        /* Hero Section */
        .hero-section {
            background-color: #0f0f1a; /* Even darker for hero */
            color: white;
            padding: 60px 20px;
            text-align: center;
            position: relative; /* Needed for sticky menu placement */
            z-index: 1; /* Ensure hero is below sticky menu initially */
            min-height: 200px; /* Give it some height */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .hero-section h1 {
            font-size: 3em;
            margin-bottom: 20px;
            color: #8bc34a; /* Green accent */
        }

        /* Small Call-out Section */
        .call-out {
            background-color: #2a2a2a;
            color: #e0e0e0;
            padding: 20px;
            margin: 20px auto;
            border-radius: 8px;
            max-width: 800px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            font-size: 0.9em;
            text-align: left; /* Align text within call-out */
            border: 1px solid #444; /* Subtle border */
        }

        .call-out h3 {
            color: #8bc34a;
            margin-top: 0;
            font-size: 1.2em;
        }

        .call-out p {
            margin-bottom: 10px;
        }

        .call-out table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .call-out th, .call-out td {
            border: 1px solid #444;
            padding: 10px;
            text-align: left;
        }

        .call-out th {
            background-color: #333;
            color: #aaddff;
            font-weight: normal;
        }

        /* Sticky Navigation Menu */
        #stickyMenu {
            position: sticky;
            top: 0;
            background-color: #1a1a2e; /* Same as body background or slightly different */
            border-bottom: 1px solid #333;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4);
            z-index: 1000;
            transition: background-color 0.3s ease;
            padding: 10px 0; /* Add padding for spacing */
            display: none; /* Hidden by default, shown when scrolled past hero */
            justify-content: center; /* Center the menu items */
        }

        #stickyMenu.active {
            display: flex; /* Show when active */
        }

        #stickyMenu ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            justify-content: center; /* Center items if they wrap */
            max-width: 800px; /* Constrain menu width */
        }

        #stickyMenu li {
            margin: 0 10px; /* Spacing between menu items */
        }

        #stickyMenu a {
            color: #e0e0e0;
            text-decoration: none;
            padding: 8px 15px;
            display: block;
            border-radius: 5px;
            transition: background-color 0.3s ease, color 0.3s ease;
            white-space: nowrap; /* Prevent menu item text from breaking */
        }

        #stickyMenu a:hover {
            background-color: #333;
            color: #8bc34a; /* Green accent on hover */
        }

        #stickyMenu a.active {
            background-color: #8bc34a; /* Active item highlight */
            color: #1a1a2e; /* Dark text for active item */
            font-weight: bold;
        }

        /* Main Content Area */
        .main-content {
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
            background-color: #1f1f3a; /* Slightly lighter than body for content background */
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            margin-top: 20px; /* Space from call-out or hero */
        }

        section {
            padding-top: 60px; /* For scroll-to-anchor offset by sticky menu height */
            margin-top: -60px; /* Counteract padding-top for correct scroll position */
            margin-bottom: 40px;
        }

        section h2 {
            color: #aaddff; /* Light blue accent for section titles */
            border-bottom: 2px solid #444;
            padding-bottom: 10px;
            margin-bottom: 20px;
            font-size: 2em;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .hero-section h1 {
                font-size: 2.5em;
            }
            .call-out {
                margin: 10px;
                padding: 15px;
            }
            .main-content {
                padding: 15px;
            }
            #stickyMenu li {
                margin: 0 5px;
            }
            #stickyMenu a {
                padding: 6px 10px;
            }
        }

        @media (max-width: 480px) {
            .hero-section h1 {
                font-size: 2em;
            }
            .call-out table, .call-out thead, .call-out tbody, .call-out th, .call-out td, .call-out tr {
                display: block;
            }
            .call-out thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            .call-out tr { border: 1px solid #444; margin-bottom: 10px; }
            .call-out td {
                border: none;
                border-bottom: 1px solid #eee;
                position: relative;
                padding-left: 50%;
                text-align: right;
            }
            .call-out td:before {
                position: absolute;
                top: 6px;
                left: 6px;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                text-align: left;
                font-weight: bold;
                color: #aaddff;
            }
            .call-out td:nth-of-type(1):before { content: "Target System"; }
            .call-out td:nth-of-type(2):before { content: "Discovery Date"; }
            .call-out td:nth-of-type(3):before { content: "Threats Identified"; }

            #stickyMenu ul {
                flex-direction: column; /* Stack menu items vertically on very small screens */
                align-items: center;
            }
            #stickyMenu li {
                width: 90%; /* Make list items take more width */
                margin-bottom: 5px;
            }
            #stickyMenu a {
                width: 100%;
                text-align: center;
            }
        }

    </style>
</head>
<body>
    <div class="hero-section">
        <h1>üîç Host Compromise Investigation</h1>
        <div class="call-out">
            <h3>Complete Forensic Analysis & Remediation</h3>
            <p>Ubuntu 24.04.2 LTS | May-June 2025</p>
            <table>
                <tr>
                    <th>Target System</th>
                    <th>Discovery Date</th>
                    <th>Threats Identified</th>
                </tr>
                <tr>
                    <td>Aiegoo_Ubuntu_Device</td>
                    <td>May 6, 2025 09:20</td>
                    <td>Mumblehard + BPFDoor</td>
                </tr>
            </table>
        </div>
    </div>

    <nav id="stickyMenu" class="sticky-menu"></nav>

    <main class="main-content">
        <section id="overview">
            <h2>Overview of Investigation</h2>
            <p>This section provides a high-level overview of the host compromise investigation. It covers the initial alert, the scope of the incident, and the primary objectives of the forensic analysis. Our aim is to determine the extent of the breach, identify the attack vectors, and ensure complete remediation to prevent future incidents. The timeline of the investigation, from initial detection to the current status, is also detailed here. This incident involved a critical Ubuntu server, 'Aiegoo_Ubuntu_Device', which was flagged on May 6, 2025, at 09:20 KST.</p>
            <p>Initial findings suggest the presence of sophisticated malware, specifically 'Mumblehard' and 'BPFDoor', indicating a targeted and persistent threat. The investigation leverages advanced forensic tools and techniques to reconstruct the attack chain and pinpoint vulnerabilities. Our team is working diligently to minimize downtime and restore the system's integrity while collecting crucial evidence for post-mortem analysis.</p>
        </section>

        <section id="initial-findings">
            <h2>Initial Findings</h2>
            <p>Upon initial triage, several critical anomalies were identified on 'Aiegoo_Ubuntu_Device'. Logs showed unusual outbound network connections to known command-and-control (C2) servers. Processes not typically associated with the server's function were running with elevated privileges. File integrity monitoring detected unauthorized modifications to system binaries and configuration files, particularly within `/etc` and `/usr/bin` directories.</p>
            <p>The presence of 'Mumblehard' was confirmed through memory forensics, revealing its sophisticated backdoor capabilities and extensive use of system resources for cryptocurrency mining and spam distribution. 'BPFDoor' was identified as a backdoor leveraging Berkeley Packet Filter (BPF) for stealthy network communication, making it difficult to detect with traditional firewalls. Evidence points to the adversaries maintaining persistence through multiple mechanisms, including cron jobs and modified systemd services.</p>
            <p>Disk images were immediately taken for offline analysis to preserve evidence. Preliminary analysis indicates data exfiltration attempts and potential lateral movement within the network, which are under active investigation.</p>
        </section>

        <section id="attack-vectors">
            <h2>Identified Attack Vectors</h2>
            <p>The primary attack vector appears to be an exploited vulnerability in an outdated public-facing service running on the Ubuntu server. Specifically, analysis of web server logs and network traffic points to a successful exploitation of CVE-2024-XXXX, a critical vulnerability in [Specific Service Name/Version, e.g., Apache Struts] that allowed for remote code execution (RCE). This initial breach likely provided the foothold for the attackers.</p>
            <p>Following the RCE, the attackers utilized a privilege escalation exploit (e.g., a kernel vulnerability or misconfigured SUID binary) to gain root access. This enabled them to deploy the 'Mumblehard' and 'BPFDoor' malware. Further investigation is ongoing to identify if phishing, supply chain compromise, or weak credentials played any role in facilitating the initial access or subsequent lateral movement.</p>
            <p>The adversaries demonstrated a strong understanding of Linux environments, using stealthy techniques to evade detection, including clearing command history, manipulating log files, and using legitimate system utilities for malicious purposes.</p>
        </section>

        <section id="remediation-steps">
            <h2>Remediation Steps Taken</h2>
            <p>Immediate containment measures were implemented: the compromised server was isolated from the network, and all suspicious processes were terminated. A full system shutdown and forensic imaging were performed to ensure no further malicious activity. All known backdoors and persistence mechanisms, including 'Mumblehard' and 'BPFDoor' components, cron jobs, and modified systemd units, were identified and removed.</p>
            <p>The compromised service was patched or removed, and all system packages were updated to their latest versions. All user accounts and SSH keys were reviewed, and compromised credentials were reset. Stronger password policies and multi-factor authentication (MFA) were enforced across all critical systems. A thorough malware scan using multiple engines confirmed the absence of known malicious payloads.</p>
            <p>Configuration hardening was applied, including tightening firewall rules, implementing SELinux/AppArmor policies, and disabling unnecessary services. Network segmentation was reviewed and enhanced to limit potential lateral movement in the future.</p>
        </section>

        <section id="post-remediation">
            <h2>Post-Remediation Activities</h2>
            <p>Following the active remediation, several post-remediation activities are underway to ensure the long-term security and resilience of the 'Aiegoo_Ubuntu_Device' and the wider network. Continuous monitoring has been established, leveraging enhanced SIEM rules and endpoint detection and response (EDR) solutions to detect any anomalous behavior proactively. Regular vulnerability scanning and penetration testing will be conducted to identify and address potential weaknesses before they can be exploited.</p>
            <p>An incident response plan review and update are in progress, incorporating lessons learned from this compromise. Security awareness training for all personnel will be reinforced, with a focus on identifying social engineering tactics and phishing attempts. Automated patching and configuration management systems are being implemented to ensure consistent security posture across all infrastructure. The goal is to build a more robust and resilient security architecture against future cyber threats.</p>
        </section>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const sections = document.querySelectorAll('.main-content section');
            const stickyMenu = document.getElementById('stickyMenu');
            const heroSection = document.querySelector('.hero-section');
            let menuCreated = false;

            // Function to generate the menu dynamically from H2s
            function createMenu() {
                if (menuCreated) return; // Prevent re-creating menu
                const ul = document.createElement('ul');
                sections.forEach(section => {
                    const h2 = section.querySelector('h2');
                    if (h2) {
                        const id = section.id;
                        const text = h2.textContent;
                        const li = document.createElement('li');
                        const a = document.createElement('a');
                        a.href = `#${id}`;
                        a.textContent = text;
                        li.appendChild(a);
                        ul.appendChild(li);

                        // Add smooth scroll behavior to newly created links
                        a.addEventListener('click', function(e) {
                            e.preventDefault();
                            const targetSection = document.querySelector(this.getAttribute('href'));
                            if (targetSection) {
                                // Adjust scroll position for fixed header
                                const headerOffset = stickyMenu.offsetHeight + 10; // Extra padding
                                const elementPosition = targetSection.getBoundingClientRect().top + window.scrollY;
                                window.scrollTo({
                                    top: elementPosition - headerOffset,
                                    behavior: 'smooth'
                                });
                            }
                        });
                    }
                });
                stickyMenu.appendChild(ul);
                menuCreated = true;
            }

            // Intersection Observer to highlight active menu item
            const observerOptions = {
                root: null, // viewport
                rootMargin: '0px 0px -50% 0px', // When section midpoint is in view
                threshold: 0 // As soon as any part of the section is visible
            };

            const observer = new IntersectionObserver((entries) => {
                let currentActive = null;
                // Find the first section that is actively intersecting
                for (let i = 0; i < entries.length; i++) {
                    const entry = entries[i];
                    if (entry.isIntersecting) {
                        currentActive = entry.target.id;
                        break; // Highlight the first one found
                    }
                }

                // If no section is intersecting, default to the first one or clear active
                if (!currentActive && sections.length > 0) {
                    // Check if we are at the very top, before the first section
                    if (window.scrollY < sections[0].offsetTop) {
                        currentActive = null; // No active section
                    } else {
                        // Fallback: if not explicitly intersecting, pick the closest one above scroll position
                        for (let i = sections.length - 1; i >= 0; i--) {
                            if (window.scrollY >= sections[i].offsetTop - stickyMenu.offsetHeight) {
                                currentActive = sections[i].id;
                                break;
                            }
                        }
                    }
                }

                // Update active class on menu items
                document.querySelectorAll('#stickyMenu a').forEach(link => {
                    if (link.getAttribute('href').substring(1) === currentActive) {
                        link.classList.add('active');
                    } else {
                        link.classList.remove('active');
                    }
                });
            }, observerOptions);

            // Observe each section
            sections.forEach(section => {
                observer.observe(section);
            });

            // Sticky menu visibility based on scroll position
            window.addEventListener('scroll', () => {
                const heroBottom = heroSection.getBoundingClientRect().bottom;
                if (heroBottom <= 0) { // When hero section has scrolled out of view
                    createMenu(); // Create menu only when needed
                    stickyMenu.classList.add('active');
                } else {
                    stickyMenu.classList.remove('active');
                    // Reset active class when hero is in view, optional
                    document.querySelectorAll('#stickyMenu a').forEach(link => {
                        link.classList.remove('active');
                    });
                }
            });

            // Initial check in case page is loaded with scroll already
            window.dispatchEvent(new Event('scroll'));
        });
    </script>
</body>
</html>
